#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
#--------------------------------
# Copyright (c) 2014 "Capensis" [http://www.capensis.com]
#
# This file is part of Canopsis.
#
# Canopsis is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Canopsis is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Canopsis.  If not, see <http://www.gnu.org/licenses/>.
# ---------------------------------

from cinit import cinit
from cstorage import get_storage
from caccount import caccount

import sys
import os
import json


class ModelRecursionError(Exception):
	def __init__(self, schema, *args, **kwargs):
		super(ModelRecursionError, self).__init__(*args, **kwargs)

		self.schema = schema

	def __str__(self):
		return 'Model {0} contains a recursion'.format(self.schema)

	def __unicode__(self):
		return u'Model {0} contains a recursion'.format(self.schema)


class Schema2MongoDB(object):
	stdtypes = [
		'object',
		'array',
		'string',
		'integer',
		'number',
		'boolean',
		'null',
		'any'
	]

	def __init__(self, *args, **kwargs):
		super(Schema2MongoDB, self).__init__(*args, **kwargs)

		self.handler = cinit()
		self.logger = handler.getLogger('schema2db')

	def load(self):
		# Load schemas

		schema_dir = os.path.expanduser('~/etc/schema.d')
		self.schemas = {}

		for filepath in os.listdir(schema_dir):
			abspath = os.path.join(schema_dir, filepath)
			schema_id = os.path.splitext(filepath)

			with open(abspath) as f:
				self.logger.info('Loading: {0}'.format(abspath))
				self.schemas[schema_id] = json.load(f)

	def build_one(self, schema_id):
		self.logger.info('Building: {0}'.format(schema_id))

		hierarchy = [schema_id]

		def _build(subschema):
			updated = False

			if 'type' in subschema and subschema['type'] not in self.stdtypes:
				if subschema['type'] in hierarchy:
					raise ModelRecursionError(schema_id)

				else:
					model = self.schemas.get(subschema['type'])
					subschema.update(model)
					updated = True

			for key in subschema:
				if key != 'type' and isinstance(subschema[key], dict):
					subupdated = False

					if 'type' in subschema:
						hierarchy.append(subschema['type'])
						subupdated = _build(subschema[key])
						del hierarchy[-1]

					else:
						subupdated = _build(subschema[key])

					if subupdated:
						updated = True

			return updated

		return _build(self.schemas[schema_id])

	def build(self):
		self.load_schemas()

		keep_going = True

		# Iterate until no update is done on any model
		while keep_going:
			keep_going = False

			for schema_id in self.schemas:
				if self.build_one(schema_id):
					keep_going = True

	def save(self):
		storage = get_storage('schemas', account=caccount(user='root', group='root')).get_backend()

		for schema_id in self.schemas:
			self.logger.info('Saving: {0}'.format(schema_id))

			storage.save({
				'_id': schema_id,
				'schema': self.schemas[schema_id]
			})

		del storage

	def __call__(self):
		self.load()
		self.build()
		self.save()


if __name__ == '__main__':
	try:
		app = Schema2MongoDB()
		app()

	except ModelRecursionError, err:
		print >>sys.stderr, "Error in model:", err
		sys.exit(1)
